name: Blue-Green Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - staging
        - production
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'ap-northeast-2'
        type: string
      gcp_zone:
        description: 'GCP Zone'
        required: true
        default: 'asia-northeast3-a'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  AWS_REGION: ${{ github.event.inputs.aws_region || 'ap-northeast-2' }}
  GCP_ZONE: ${{ github.event.inputs.gcp_zone || 'asia-northeast3-a' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production') || 'staging' }}

jobs:
  # Blue-Green ë°°í¬ ì¤€ë¹„
  prepare-deployment:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      deployment-id: ${{ steps.deployment-id.outputs.id }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.ENVIRONMENT }}-blue
          type=raw,value=${{ env.ENVIRONMENT }}-green

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate deployment ID
      id: deployment-id
      run: echo "id=$(date +%s)" >> $GITHUB_OUTPUT

  # AWS Blue-Green ë°°í¬
  deploy-aws:
    runs-on: ubuntu-latest
    needs: prepare-deployment
    environment: ${{ env.ENVIRONMENT }}-aws
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Blue environment (AWS)
      run: |
        # í˜„ì¬ íŠ¸ë˜í”½ì´ Greenì— ìˆëŠ”ì§€ í™•ì¸
        CURRENT_COLOR=$(aws elbv2 describe-target-groups --names my-app-targets --query 'TargetGroups[0].TargetGroupName' --output text | grep -o 'green\|blue' || echo 'blue')
        
        if [ "$CURRENT_COLOR" = "green" ]; then
          NEW_COLOR="blue"
        else
          NEW_COLOR="green"
        fi
        
        echo "Deploying to $NEW_COLOR environment"
        
        # Auto Scaling Group ì—…ë°ì´íŠ¸
        aws autoscaling update-auto-scaling-group \
          --auto-scaling-group-name my-app-asg-$NEW_COLOR \
          --launch-template LaunchTemplateName=my-app-template,Version='$Latest'
        
        # ì¸ìŠ¤í„´ìŠ¤ ìƒˆë¡œê³ ì¹¨
        aws autoscaling start-instance-refresh \
          --auto-scaling-group-name my-app-asg-$NEW_COLOR \
          --preferences MinHealthyPercentage=50,InstanceWarmup=300

    - name: Wait for Blue deployment to be ready
      run: |
        # ë°°í¬ ì™„ë£Œ ëŒ€ê¸°
        aws autoscaling wait instance-refresh-complete \
          --auto-scaling-group-name my-app-asg-$NEW_COLOR
        
        # í—¬ìŠ¤ ì²´í¬ ëŒ€ê¸°
        for i in {1..30}; do
          if curl -f -s http://$ALB_DNS/health > /dev/null; then
            echo "Blue environment is healthy"
            break
          else
            echo "Waiting for Blue environment to be healthy... ($i/30)"
            sleep 10
          fi
        done

    - name: Switch traffic to Blue (AWS)
      run: |
        # Target Group ì—…ë°ì´íŠ¸
        aws elbv2 modify-target-group \
          --target-group-arn $TARGET_GROUP_ARN \
          --health-check-path /health \
          --health-check-interval-seconds 30
        
        # íŠ¸ë˜í”½ ì „í™˜
        aws elbv2 modify-listener \
          --listener-arn $LISTENER_ARN \
          --default-actions Type=forward,TargetGroupArn=$TARGET_GROUP_ARN

    - name: Clean up old Green environment (AWS)
      if: success()
      run: |
        # ì´ì „ í™˜ê²½ ì •ë¦¬
        aws autoscaling update-auto-scaling-group \
          --auto-scaling-group-name my-app-asg-$OLD_COLOR \
          --min-size 0 \
          --max-size 0 \
          --desired-capacity 0

  # GCP Blue-Green ë°°í¬
  deploy-gcp:
    runs-on: ubuntu-latest
    needs: prepare-deployment
    environment: ${{ env.ENVIRONMENT }}-gcp
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Deploy to Blue environment (GCP)
      run: |
        # í˜„ì¬ íŠ¸ë˜í”½ì´ Greenì— ìˆëŠ”ì§€ í™•ì¸
        CURRENT_COLOR=$(gcloud compute instance-groups managed describe my-app-mig-green --zone=${{ env.GCP_ZONE }} --format="value(name)" 2>/dev/null | grep -o 'green\|blue' || echo 'blue')
        
        if [ "$CURRENT_COLOR" = "green" ]; then
          NEW_COLOR="blue"
        else
          NEW_COLOR="green"
        fi
        
        echo "Deploying to $NEW_COLOR environment"
        
        # Managed Instance Group ì—…ë°ì´íŠ¸
        gcloud compute instance-groups managed rolling-action start-update my-app-mig-$NEW_COLOR \
          --zone=${{ env.GCP_ZONE }} \
          --template=my-app-template-$NEW_COLOR \
          --max-unavailable=1 \
          --min-ready=2

    - name: Wait for Blue deployment to be ready
      run: |
        # ë°°í¬ ì™„ë£Œ ëŒ€ê¸°
        gcloud compute instance-groups managed wait-until-stable my-app-mig-$NEW_COLOR \
          --zone=${{ env.GCP_ZONE }}
        
        # í—¬ìŠ¤ ì²´í¬ ëŒ€ê¸°
        for i in {1..30}; do
          if curl -f -s http://$LB_IP/health > /dev/null; then
            echo "Blue environment is healthy"
            break
          else
            echo "Waiting for Blue environment to be healthy... ($i/30)"
            sleep 10
          fi
        done

    - name: Switch traffic to Blue (GCP)
      run: |
        # Backend Service ì—…ë°ì´íŠ¸
        gcloud compute backend-services update my-app-backend \
          --global \
          --backend-group=my-app-mig-$NEW_COLOR \
          --backend-group-zone=${{ env.GCP_ZONE }}

    - name: Clean up old Green environment (GCP)
      if: success()
      run: |
        # ì´ì „ í™˜ê²½ ì •ë¦¬
        gcloud compute instance-groups managed resize my-app-mig-$OLD_COLOR \
          --zone=${{ env.GCP_ZONE }} \
          --size=0

  # Kubernetes Blue-Green ë°°í¬
  deploy-k8s:
    runs-on: ubuntu-latest
    needs: prepare-deployment
    environment: ${{ env.ENVIRONMENT }}-k8s
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl for AWS EKS
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name my-app-cluster

    - name: Deploy to Blue environment (K8s)
      run: |
        # í˜„ì¬ íŠ¸ë˜í”½ì´ Greenì— ìˆëŠ”ì§€ í™•ì¸
        CURRENT_COLOR=$(kubectl get service my-app-service -o jsonpath='{.spec.selector.version}' || echo 'blue')
        
        if [ "$CURRENT_COLOR" = "green" ]; then
          NEW_COLOR="blue"
        else
          NEW_COLOR="green"
        fi
        
        echo "Deploying to $NEW_COLOR environment"
        
        # Blue í™˜ê²½ ë°°í¬
        kubectl apply -f k8s/overlays/${{ env.ENVIRONMENT }}/$NEW_COLOR/
        
        # ë°°í¬ ìƒíƒœ í™•ì¸
        kubectl rollout status deployment/my-app-$NEW_COLOR --timeout=300s

    - name: Wait for Blue deployment to be ready
      run: |
        # í—¬ìŠ¤ ì²´í¬ ëŒ€ê¸°
        for i in {1..30}; do
          if kubectl get pods -l app=my-app,version=$NEW_COLOR --field-selector=status.phase=Running | grep -q Running; then
            echo "Blue environment is ready"
            break
          else
            echo "Waiting for Blue environment to be ready... ($i/30)"
            sleep 10
          fi
        done

    - name: Switch traffic to Blue (K8s)
      run: |
        # Service ì—…ë°ì´íŠ¸
        kubectl patch service my-app-service -p '{"spec":{"selector":{"version":"'$NEW_COLOR'"}}}'
        
        # íŠ¸ë˜í”½ ì „í™˜ í™•ì¸
        kubectl get service my-app-service -o jsonpath='{.spec.selector.version}'

    - name: Clean up old Green environment (K8s)
      if: success()
      run: |
        # ì´ì „ í™˜ê²½ ì •ë¦¬
        kubectl scale deployment my-app-$OLD_COLOR --replicas=0

  # ë°°í¬ í›„ ê²€ì¦
  post-deployment-verification:
    runs-on: ubuntu-latest
    needs: [deploy-aws, deploy-gcp, deploy-k8s]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run health checks
      run: |
        # AWS í—¬ìŠ¤ ì²´í¬
        if [ ! -z "$ALB_DNS" ]; then
          echo "Checking AWS ALB health..."
          curl -f -s http://$ALB_DNS/health || echo "AWS ALB health check failed"
        fi
        
        # GCP í—¬ìŠ¤ ì²´í¬
        if [ ! -z "$LB_IP" ]; then
          echo "Checking GCP Load Balancer health..."
          curl -f -s http://$LB_IP/health || echo "GCP Load Balancer health check failed"
        fi
        
        # Kubernetes í—¬ìŠ¤ ì²´í¬
        echo "Checking Kubernetes pods..."
        kubectl get pods -l app=my-app

    - name: Run smoke tests
      run: |
        # ê°„ë‹¨í•œ ìŠ¤ëª¨í¬ í…ŒìŠ¤íŠ¸
        if [ ! -z "$ALB_DNS" ]; then
          echo "Running smoke tests on AWS ALB..."
          for i in {1..5}; do
            curl -f -s http://$ALB_DNS/ | grep -q "My App" && echo "Test $i passed" || echo "Test $i failed"
          done
        fi

    - name: Send deployment notification
      if: always()
      run: |
        # Slack ì•Œë¦¼
        if [ ! -z "$SLACK_WEBHOOK_URL" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"ğŸš€ Blue-Green Deployment completed for '${{ env.ENVIRONMENT }}' environment"}' \
            $SLACK_WEBHOOK_URL
        fi
        
        # Discord ì•Œë¦¼
        if [ ! -z "$DISCORD_WEBHOOK_URL" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"content":"ğŸš€ Blue-Green Deployment completed for '${{ env.ENVIRONMENT }}' environment"}' \
            $DISCORD_WEBHOOK_URL
        fi
